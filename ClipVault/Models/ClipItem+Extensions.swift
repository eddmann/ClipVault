//
//  ClipItem+Extensions.swift
//  ClipVault
//
//  Created by Edd on 09/10/2025.
//

import Foundation
import CoreData

// Note: Core Data properties are auto-generated by Xcode in ClipItem+CoreDataProperties.swift
// This file defines the class and adds convenience extensions

@objc(ClipItem)
public class ClipItem: NSManagedObject {
    // Properties are defined in the auto-generated ClipItem+CoreDataProperties.swift
}

// MARK: - Convenience Extensions

extension ClipItem {

    /// Returns the decrypted text content
    func getDecryptedText() -> String? {
        guard let encryptedData = textContent else { return nil }
        return try? EncryptionManager.shared.decryptString(encryptedData)
    }

    /// Sets the text content with encryption
    func setEncryptedText(_ text: String) throws {
        textContent = try EncryptionManager.shared.encryptString(text)
    }

    /// Returns the decrypted RTF data
    func getDecryptedRTF() -> Data? {
        guard let encryptedData = rtfData else { return nil }
        return try? EncryptionManager.shared.decrypt(encryptedData)
    }

    /// Sets the RTF data with encryption
    func setEncryptedRTF(_ data: Data) throws {
        rtfData = try EncryptionManager.shared.encrypt(data)
    }

    /// Returns a preview string for display (truncated)
    func getPreviewText(maxLength: Int = 60) -> String {
        // Both text and RTF items have plain text stored in textContent
        if let text = getDecryptedText() {
            let preview = text.replacingOccurrences(of: "\n", with: " ")
            return preview.count > maxLength ? String(preview.prefix(maxLength)) + "..." : preview
        }
        return "[Unknown]"
    }

    /// Returns a relative time string (e.g., "2m ago", "1h ago")
    func getRelativeTimeString() -> String {
        guard let dateAdded = dateAdded else { return "Unknown" }
        let now = Date()
        let interval = now.timeIntervalSince(dateAdded)

        let minutes = Int(interval / 60)
        let hours = Int(interval / 3600)
        let days = Int(interval / 86400)

        if minutes < 1 {
            return "Just now"
        } else if minutes < 60 {
            return "\(minutes)m ago"
        } else if hours < 24 {
            return "\(hours)h ago"
        } else if days < 7 {
            return "\(days)d ago"
        } else {
            let formatter = DateFormatter()
            formatter.dateStyle = .short
            formatter.timeStyle = .none
            return formatter.string(from: dateAdded)
        }
    }

    /// Computes SHA256 hash for deduplication
    static func computeHash(for data: Data) -> String {
        let hash = SHA256.hash(data: data)
        return hash.compactMap { String(format: "%02x", $0) }.joined()
    }

    /// Computes hash for a string
    static func computeHash(for string: String) -> String {
        guard let data = string.data(using: .utf8) else { return "" }
        return computeHash(for: data)
    }
}

// MARK: - Fetch Requests

extension ClipItem {

    /// Fetch all items sorted by date (pinned first)
    static func fetchAllRequest() -> NSFetchRequest<ClipItem> {
        let request = fetchRequest()
        request.sortDescriptors = [
            NSSortDescriptor(keyPath: \ClipItem.isPinned, ascending: false),
            NSSortDescriptor(keyPath: \ClipItem.dateAdded, ascending: false)
        ]
        return request
    }

    /// Fetch items matching a search query
    static func searchRequest(query: String) -> NSFetchRequest<ClipItem> {
        let request = fetchRequest()
        // Note: We can't search encrypted content directly, so this will be limited
        // In practice, we'll need to fetch all and decrypt in memory for search
        request.sortDescriptors = [
            NSSortDescriptor(keyPath: \ClipItem.isPinned, ascending: false),
            NSSortDescriptor(keyPath: \ClipItem.dateAdded, ascending: false)
        ]
        return request
    }

    /// Fetch item by hash for deduplication
    static func fetchByHashRequest(hash: String) -> NSFetchRequest<ClipItem> {
        let request = fetchRequest()
        request.predicate = NSPredicate(format: "contentHash == %@", hash)
        request.fetchLimit = 1
        return request
    }
}

// MARK: - Import CryptoKit for SHA256

import CryptoKit
